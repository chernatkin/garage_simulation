package org.chernatkin.garage.simulation.service;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import javax.annotation.PostConstruct;
import javax.inject.Inject;
import javax.sql.DataSource;

import org.chernatkin.garage.simulation.exception.CarNotFoundException;
import org.chernatkin.garage.simulation.exception.NoFreePlacesException;

public class GarageDao {
    
    private static final int FLOORS_NUMBER = 3;
    
    private static final int PLACES_ON_FLOOR = 3;
    
    private static final String PLACE_ID_COLUMN = "place_id";
    
    private static final String FLOOR_COLUMN = "floor";
    
    private static final String PLACE_NUMBER_COLUMN = "place_number";
    
    private static final String CAR_ID_COLUMN = "car_id";
    
    @Inject
    private DataSource dataSource;
    
    @PostConstruct
    //TODO: Remove this method if used db as dedicated process, not in memory db
    public void recreateDatabase() throws SQLException {
        final Connection conn = dataSource.getConnection();
        conn.createStatement().execute("DROP TABLE garage_place IF EXISTS");
        
        conn.createStatement().execute("CREATE TABLE garage_place ( "
                + PLACE_ID_COLUMN + " BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY, "
                + FLOOR_COLUMN + " SMALLINT NOT NULL, "
                + PLACE_NUMBER_COLUMN + " SMALLINT NOT NULL, "
                + CAR_ID_COLUMN + " BIGINT"
                + ")");
        
        final PreparedStatement ps = conn.prepareStatement("INSERT INTO garage_place (floor, place_number) "
                                                         + "VALUES (?, ?)");
        
        for(int i = 1; i <= FLOORS_NUMBER; i++){
            for(int j = 1; j <= PLACES_ON_FLOOR; j++){
                ps.setInt(1, i);
                ps.setInt(2, j);
                ps.addBatch();
            }
        }
        
        ps.executeBatch();
        conn.close();
    }
    
    public GaragePlace lockFreePlace(final long carId) throws SQLException, NoFreePlacesException {
        try(final Connection conn = dataSource.getConnection()) {
            
            while (true){
                GaragePlace place = tryLockPlace(conn, carId);
                if (place != null){
                    return place;
                }
            }
        }
    }
    
    private GaragePlace tryLockPlace(final Connection conn, final long carId) throws SQLException, NoFreePlacesException {
        final List<GaragePlace> places = queryPlaces(conn, "SELECT * FROM garage_place WHERE car_id IS NULL OR car_id = ? ORDER BY car_id NULLS LAST LIMIT 1", carId);
        if(places.isEmpty()){
            throw new NoFreePlacesException();
        }
        
        final GaragePlace place = places.get(0);
        if(place.getCarId() != null){
            assert place.getCarId() == carId;
            return place;
        }
        final int updatedRows = executeUpdate(conn, 
                                              "UPDATE garage_place SET car_id = ? WHERE place_id = ? AND car_id IS NULL", 
                                              carId, place.getPlaceId());
        if(updatedRows == 0){
            return null;
        }
        place.setCarId(carId);
        return place;
    }
    
    public int releasePlace(final long carId) throws SQLException {
        try(final Connection conn = dataSource.getConnection()) {
            return executeUpdate(conn, "UPDATE garage_place SET car_id = NULL WHERE car_id = ?", carId);
        }
    }
    
    public GaragePlace getCarPlace(final long carId) throws SQLException, CarNotFoundException {
        try(final Connection conn = dataSource.getConnection()) {
            final List<GaragePlace> places = queryPlaces(conn, "SELECT * FROM garage_place WHERE car_id = ?", carId);
            if(places.isEmpty()) {
                throw new CarNotFoundException();
            }
            return places.get(0);
        }
    }
    
    public int freePlacesCount() throws SQLException {
        try(final Connection conn = dataSource.getConnection()) {
            final ResultSet rs = conn.createStatement().executeQuery("SELECT COUNT(*) AS free_count FROM garage_place WHERE car_id IS NULL");
            rs.next();
            return rs.getInt("free_count");
        }
    }
    
    public List<GaragePlace> getAllPlaces() throws SQLException, CarNotFoundException {
        try(final Connection conn = dataSource.getConnection()) {
            return queryPlaces(conn, "SELECT * FROM garage_place");
        }
    }
    
    private int executeUpdate(final Connection conn, final String sql, Number... params) throws SQLException {
        return applyParams(conn.prepareStatement(sql), params).executeUpdate();
    }
    
    private List<GaragePlace> queryPlaces(final Connection conn, String sql, Number... params) throws SQLException {
        final ResultSet rs = applyParams(conn.prepareStatement(sql), params).executeQuery();
        
        final List<GaragePlace> places = new ArrayList<>();
        while(rs.next()){
            final Long carId = Optional.ofNullable(rs.getObject(CAR_ID_COLUMN))
                                       .map(obj -> ((Number)obj).longValue())
                                       .orElse(null);
            
            places.add(new GaragePlace(rs.getInt(PLACE_ID_COLUMN),
                                                      rs.getInt(FLOOR_COLUMN),
                                                      rs.getInt(PLACE_NUMBER_COLUMN),
                                                      carId));
        }
        
        rs.close();
        return places;
    }
    
    private PreparedStatement applyParams(final PreparedStatement ps, Number... params) throws SQLException {
        if(params == null) {
            return ps;
        }
        for(int i = 0; i < params.length; i++){
            ps.setLong(i + 1, params[i].longValue());
        }
        return ps;
    }
}
